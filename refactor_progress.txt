

** TOOOO DOOOOS **

* Done for now! XOXO

*** RAIIIIIII ***

* Done for now! XOXO

*** Responsibility Refactor ***

X Separate out input, update and collision handling from the generic Update()

X Separate the Render function into its separate states, while also adding in the stuff from Run that should be in Render

X Split up Game.h into multiple header-files that define specific things

X Go over two-step initialization of all objects and work to initialize everything as tightly as possible in constructors (this might end up being several commits)

*** Unify Data Types ***

X Look for screen-positioning related things and find out whether it has to be in float, or could be in int, and use whatever it might need to be for all primitive types: position, rectangles, etc
^ Also look for redundant information like this, or where it is represented differently in different things (everything should use a Vector2 for position for example)
^ Do not change anything yet, just gather information!

>> NOTE: using float where it's an option seems to be most compatible with Raylib

X Go through it again, refactoring representation as needed

*** Redundancy reduction / responsibility correction ***

* Look for redundant fields, or fields that are misused, and make notes
> Alien.Color
> Alien.type

* Create a Playfield rectangle that can be sent to entities that need it (to calculate boundaries)

*** Collision System ***

X The collision functionality seems insanely over-engineered! It checks the start and end point of a line by way of circular collision instead of just comparing two circles (or two boxes..)

X Alright, I think this is the "collision system" I'll use: each collideable object has a "GetCollisionRect" and an OnCollision function
X Separate the projectile lists so player and enemy projectiles are separate, for collision purposes
X Do all the different collision checks!

() In hindsight, I could probably just have used circular collision with radius for a slightly simpler interface not requiring size, but oh well

*** Tightening pass ***

* Tighten all classes, removing unused data members and improving Update()-implementations

*** Rendering ***

* Plan: make it so the resource manager is interacted with via string_views instead of owning textures as data members
^ This allows for game objects or render classes to know about a texture as a string instead of as a more complex resource
^ The resource manager is then passed along the render calls to where it is needed

X Prototype this system in parallell to the existing one, test with Alien as that class is already tightened and pretty clean

X Create an Animation class that holds a string to a texture, cell width/height, number of frames, ticks per frame, a target rectangle, and an offset!
^ Let Alien implement this Animation class and be rendered by it

X Refactor again so Animation becomes AnimatedSprite, inheriting from Sprite and a separate class that is a SpriteRenderer / AnimatedSpriteRenderer

X Implement the static Sprite on Wall and Projectile

X Finish the AnimatedSprite and implement it on Player

* Create a "DotRenderer" to support the rendering of the background, and then just have the background hold the positions and sizes (dots) required

* Do some basic clean up! That is, separate things properly into their .h and .cpp classes etc

*** State Handling ***

* Should the states be separated? If so, now is the time!

*** WARNINGS AS ERRORS ***

* Turn on Warnings As Errors and enjoy the show!

*** Const, noexcept and stuff like that! ***

* Algorithms! Replace for-loops and such with algorithms when applicapble
> std::erase_if(enemies, [](const auto& e) { return !e.IsActive(); }); (for erasing inactive enemies)

* Try some Const-chasing in the rendering code and see if you can get all/most rendering functions to become const

* Text formatting should use std-formatting instead of c-style

* Look for single-argument constructors that can be explicit

* Add "final" to all non-inherited classes